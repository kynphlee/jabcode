# Panama Wrapper - Quick Start Guide

## What You Have

A complete **Panama FFM wrapper structure** for JABCode on the `panama-poc` branch:

```
panama-wrapper/
├── README.md                    # Overview and documentation
├── QUICKSTART.md               # This file
├── IMPLEMENTATION_GUIDE.md     # Detailed implementation steps
├── pom.xml                     # Maven build with jextract integration
├── jextract.sh                 # Script to generate bindings
├── .gitignore                  # Ignore generated files
└── src/
    ├── main/java/com/jabcode/panama/
    │   ├── JABCodeEncoder.java  # High-level encoding API (template)
    │   └── JABCodeDecoder.java  # High-level decoding API (template)
    └── test/java/com/jabcode/panama/
        └── JABCodeEncoderTest.java  # Unit tests

# Generated by jextract (not committed):
└── target/generated-sources/jextract/
    └── com/jabcode/panama/bindings/
        ├── jabcode_h.java       # Main FFM bindings
        ├── jab_data.java        # Data structure
        ├── jab_encode.java      # Encode structure
        └── ...                  # Other bindings
```

## Key Differences from javacpp-wrapper

| Aspect | JNI (javacpp-wrapper) | Panama (this) |
|--------|----------------------|---------------|
| Location | `/javacpp-wrapper/` | `/panama-wrapper/` |
| Native Code | 500+ lines C++ | **0 lines** |
| Java Version | Java 11+ | **Java 23+** |
| Dependencies | JavaCPP, C++ compiler | **None** |
| Binding Gen | Manual | **Automatic (jextract)** |
| Memory Mgmt | Manual | **Automatic (arenas)** |
| Android | ✅ Yes | ❌ No (use swift-java-poc) |
| Desktop | ✅ Yes | ✅ Yes (JDK 23+) |

## Prerequisites

**Already Available:**
- ✅ JDK 21 (system default)
- ✅ JDK 23 (project JDK)
- ✅ JDK 25 in `/home/kynphlee/tools/compilers/java/jdk-25.0.1`
- ✅ JABCode C library (needs to be built)

**Still Needed:**
- ⚠️ jextract tool

## Step-by-Step Setup

### 1. Use JDK 25 (Has Best Panama Support)

```bash
export JAVA_HOME=/home/kynphlee/tools/compilers/java/jdk-25.0.1
export PATH="$JAVA_HOME/bin:$PATH"

# Verify
java --version
# Should show: java version "25.0.1" ...
```

### 2. Check for jextract

```bash
which jextract
jextract --version
```

**If jextract is not found:**
- JDK 25 may include it in `$JAVA_HOME/bin/jextract`
- Otherwise download from: https://jdk.java.net/jextract/

### 3. Build JABCode Native Library

```bash
cd ../src/jabcode
make clean && make

# Verify library exists
ls -lh ../../lib/libjabcode.*
# Should see: libjabcode.a or libjabcode.so
```

### 4. Generate Panama Bindings

```bash
cd /mnt/b34628fa-d41e-4c37-8caf-f06a6ecbb1ae/projects/practice/barcode/jabcode/panama-wrapper

# Run jextract
./jextract.sh
```

**Expected output:**
```
JABCode Panama Binding Generator
==================================

Configuration:
  JABCode Header: ../src/jabcode/include/jabcode.h
  Include Dir:    ../src/jabcode/include
  Output Dir:     target/generated-sources/jextract
  Package:        com.jabcode.panama.bindings
  Java Version:   25

Generating Panama bindings...

✓ Bindings generated successfully

Generated files:
target/generated-sources/jextract/com/jabcode/panama/bindings/jabcode_h.java
target/generated-sources/jextract/com/jabcode/panama/bindings/jab_data.java
...
```

### 5. Inspect Generated Bindings

```bash
# See what was generated
find target/generated-sources/jextract -name "*.java" | head -10

# Look at main bindings file
cat target/generated-sources/jextract/com/jabcode/panama/bindings/jabcode_h.java | head -50

# Check data structures
grep -A 20 "class jab_data" target/generated-sources/jextract/com/jabcode/panama/bindings/jab_data.java
```

### 6. Complete the Implementation

Now that bindings are generated, complete `JABCodeEncoder.java` and `JABCodeDecoder.java`.

See `IMPLEMENTATION_GUIDE.md` for detailed instructions.

Key tasks:
1. Import generated bindings: `import static com.jabcode.panama.bindings.jabcode_h.*;`
2. Implement `encodeWithConfig()` using Panama FFM API
3. Handle flexible array members in C structs
4. Implement `decodeEx()` for decoding

### 7. Build with Maven

```bash
# Build (will include generated sources automatically)
mvn clean package

# Run tests
mvn test
```

### 8. Test the Implementation

```bash
# Run with native access
mvn test -Djava.library.path=../lib

# Or manually
java --enable-native-access=ALL-UNNAMED \
     -Djava.library.path=../lib \
     -cp target/jabcode-panama-1.0.0-SNAPSHOT.jar:target/test-classes \
     org.junit.platform.console.ConsoleLauncher \
     --scan-classpath
```

## Example Usage (Once Implemented)

```java
import com.jabcode.panama.JABCodeEncoder;

public class Example {
    public static void main(String[] args) {
        // Create encoder
        var encoder = new JABCodeEncoder();
        
        // Configure
        var config = JABCodeEncoder.Config.builder()
            .colorNumber(8)
            .eccLevel(5)
            .moduleSize(12)
            .build();
        
        // Encode
        byte[] encoded = encoder.encodeWithConfig("Hello Panama!", config);
        
        System.out.println("Encoded: " + encoded.length + " bytes");
    }
}
```

## Comparison: Before vs After

### Current JNI Wrapper (javacpp-wrapper)

**C++ JNI Wrapper:**
```cpp
// javacpp-wrapper/src/main/c/JABCodeNative_jni.cpp (500+ lines)
JNIEXPORT jbyteArray JNICALL 
Java_com_jabcode_JABCodeNative_encode(JNIEnv *env, jobject obj, jstring data) {
    const char *nativeData = (*env)->GetStringUTFChars(env, data, 0);
    
    jab_encode* enc = createEncode(8, 1);
    // ... manual memory management
    // ... JNI type conversions
    // ... error-prone boilerplate
    
    (*env)->ReleaseStringUTFChars(env, data, nativeData);
    return result;
}
```

**Java Usage:**
```java
JABCodeNative native = new JABCodeNative();
byte[] result = native.encode(data);
```

### Panama Wrapper (This)

**No C++ Code - Pure Java:**
```java
// panama-wrapper/src/main/java/com/jabcode/panama/JABCodeEncoder.java (~200 lines)
public byte[] encodeWithConfig(String data, Config config) {
    try (Arena arena = Arena.ofConfined()) {
        MemorySegment enc = createEncode(arena, config.getColorNumber(), 1);
        // ... type-safe Panama FFM calls
        // ... automatic memory management
        return pixels;
    } // Auto cleanup
}
```

**Java Usage (Same API, Better Implementation):**
```java
JABCodeEncoder encoder = new JABCodeEncoder();
byte[] result = encoder.encode(data, 8, 5);
```

## Build Structure Comparison

### JNI Build Process
1. Write C++ JNI wrapper (`JABCodeNative_jni.cpp`)
2. Compile C++ with JNI headers
3. Link with libjabcode
4. Create platform-specific .so/.dll
5. Load in Java with `System.loadLibrary()`
6. Repeat for each platform

### Panama Build Process
1. Run `jextract` once (generates Java bindings)
2. Compile Java code
3. Done! (Uses existing libjabcode)

## Development Workflow

### Making Changes to C API

**JNI Approach:**
1. Update C header
2. **Manually update C++ JNI wrapper** (error-prone)
3. Recompile C++
4. Test

**Panama Approach:**
1. Update C header
2. **Run `./jextract.sh`** (automatic)
3. Adjust Java code if needed
4. Test

## Platform Support

| Platform | JNI | Panama |
|----------|-----|--------|
| **Linux Desktop** | ✅ | ✅ |
| **macOS Desktop** | ✅ | ✅ |
| **Windows Desktop** | ✅ | ✅ |
| **Cloud/Server** | ✅ | ✅ (JDK 23+) |
| **Android** | ✅ | ❌ (use swift-java-poc) |

## Performance Expectations

Based on Panama benchmarks from other projects:
- **Encoding:** 95-105% of JNI (often faster)
- **Decoding:** 95-105% of JNI
- **Memory:** Lower overhead (arena allocation)
- **Warmup:** Comparable

Panama is often **faster** because:
- Fewer memory copies
- Better JIT optimization
- No JNI boundary overhead

## Next Steps

1. **Install jextract** (if not in JDK 25)
2. **Run `./jextract.sh`** to generate bindings
3. **Review generated code** in `target/generated-sources/jextract/`
4. **Complete implementation** in `JABCodeEncoder.java` and `JABCodeDecoder.java`
5. **Add tests** (enable disabled tests in `JABCodeEncoderTest.java`)
6. **Benchmark** against JNI version

## Troubleshooting

### jextract not found
```bash
# Check JDK 25
ls $JAVA_HOME/bin/jextract

# Or download standalone
# https://jdk.java.net/jextract/
```

### Library not found
```bash
export LD_LIBRARY_PATH=/mnt/b34628fa-d41e-4c37-8caf-f06a6ecbb1ae/projects/practice/barcode/jabcode/lib:$LD_LIBRARY_PATH
```

### Illegal native access
```bash
java --enable-native-access=ALL-UNNAMED YourClass
```

## Resources

- **JEP 454 (Panama FFM):** https://openjdk.org/jeps/454
- **jextract Guide:** https://github.com/openjdk/jextract
- **Implementation Guide:** `./IMPLEMENTATION_GUIDE.md`
- **Comparison Document:** `/memory-bank/integration-approaches-comparison.md`
- **Platform Matrix:** `/memory-bank/platform-feature-matrix.md`

## Success Criteria

✅ You'll know it's working when:
1. `./jextract.sh` runs without errors
2. Maven build succeeds: `mvn clean package`
3. Tests pass: `mvn test`
4. Can encode/decode JABCode from pure Java
5. No C++ compilation needed

## Questions?

Check:
1. `IMPLEMENTATION_GUIDE.md` - Detailed implementation steps
2. `README.md` - Overview and architecture
3. `/memory-bank/research/panama-poc/` - Research documentation
