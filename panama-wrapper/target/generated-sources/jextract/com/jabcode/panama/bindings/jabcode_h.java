// Generated by jextract

package com.jabcode.panama.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class jabcode_h extends jabcode_h$shared {

    jabcode_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("jabcode"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());


    private static class createEncode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_POINTER,
            jabcode_h.C_INT,
            jabcode_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("createEncode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_encode *createEncode(jab_int32 color_number, jab_int32 symbol_number)
     * }
     */
    public static FunctionDescriptor createEncode$descriptor() {
        return createEncode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_encode *createEncode(jab_int32 color_number, jab_int32 symbol_number)
     * }
     */
    public static MethodHandle createEncode$handle() {
        return createEncode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_encode *createEncode(jab_int32 color_number, jab_int32 symbol_number)
     * }
     */
    public static MemorySegment createEncode$address() {
        return createEncode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_encode *createEncode(jab_int32 color_number, jab_int32 symbol_number)
     * }
     */
    public static MemorySegment createEncode(int color_number, int symbol_number) {
        var mh$ = createEncode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("createEncode", color_number, symbol_number);
            }
            return (MemorySegment)mh$.invokeExact(color_number, symbol_number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class destroyEncode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("destroyEncode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void destroyEncode(jab_encode *enc)
     * }
     */
    public static FunctionDescriptor destroyEncode$descriptor() {
        return destroyEncode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void destroyEncode(jab_encode *enc)
     * }
     */
    public static MethodHandle destroyEncode$handle() {
        return destroyEncode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void destroyEncode(jab_encode *enc)
     * }
     */
    public static MemorySegment destroyEncode$address() {
        return destroyEncode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void destroyEncode(jab_encode *enc)
     * }
     */
    public static void destroyEncode(MemorySegment enc) {
        var mh$ = destroyEncode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("destroyEncode", enc);
            }
            mh$.invokeExact(enc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateJABCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_INT,
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateJABCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_int32 generateJABCode(jab_encode *enc, jab_data *data)
     * }
     */
    public static FunctionDescriptor generateJABCode$descriptor() {
        return generateJABCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_int32 generateJABCode(jab_encode *enc, jab_data *data)
     * }
     */
    public static MethodHandle generateJABCode$handle() {
        return generateJABCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_int32 generateJABCode(jab_encode *enc, jab_data *data)
     * }
     */
    public static MemorySegment generateJABCode$address() {
        return generateJABCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_int32 generateJABCode(jab_encode *enc, jab_data *data)
     * }
     */
    public static int generateJABCode(MemorySegment enc, MemorySegment data) {
        var mh$ = generateJABCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateJABCode", enc, data);
            }
            return (int)mh$.invokeExact(enc, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class decodeJABCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER,
            jabcode_h.C_INT,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("decodeJABCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCode(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status)
     * }
     */
    public static FunctionDescriptor decodeJABCode$descriptor() {
        return decodeJABCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCode(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status)
     * }
     */
    public static MethodHandle decodeJABCode$handle() {
        return decodeJABCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCode(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status)
     * }
     */
    public static MemorySegment decodeJABCode$address() {
        return decodeJABCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_data *decodeJABCode(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status)
     * }
     */
    public static MemorySegment decodeJABCode(MemorySegment bitmap, int mode, MemorySegment status) {
        var mh$ = decodeJABCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("decodeJABCode", bitmap, mode, status);
            }
            return (MemorySegment)mh$.invokeExact(bitmap, mode, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class decodeJABCodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER,
            jabcode_h.C_INT,
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER,
            jabcode_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("decodeJABCodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeEx(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, jab_decoded_symbol *symbols, jab_int32 max_symbol_number)
     * }
     */
    public static FunctionDescriptor decodeJABCodeEx$descriptor() {
        return decodeJABCodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeEx(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, jab_decoded_symbol *symbols, jab_int32 max_symbol_number)
     * }
     */
    public static MethodHandle decodeJABCodeEx$handle() {
        return decodeJABCodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeEx(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, jab_decoded_symbol *symbols, jab_int32 max_symbol_number)
     * }
     */
    public static MemorySegment decodeJABCodeEx$address() {
        return decodeJABCodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeEx(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, jab_decoded_symbol *symbols, jab_int32 max_symbol_number)
     * }
     */
    public static MemorySegment decodeJABCodeEx(MemorySegment bitmap, int mode, MemorySegment status, MemorySegment symbols, int max_symbol_number) {
        var mh$ = decodeJABCodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("decodeJABCodeEx", bitmap, mode, status, symbols, max_symbol_number);
            }
            return (MemorySegment)mh$.invokeExact(bitmap, mode, status, symbols, max_symbol_number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class decodeJABCodeWithObservations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER,
            jabcode_h.C_INT,
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER,
            jabcode_h.C_INT,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("decodeJABCodeWithObservations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeWithObservations(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, void *observation_buffer, jab_int32 buffer_capacity, jab_int32 *observation_count)
     * }
     */
    public static FunctionDescriptor decodeJABCodeWithObservations$descriptor() {
        return decodeJABCodeWithObservations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeWithObservations(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, void *observation_buffer, jab_int32 buffer_capacity, jab_int32 *observation_count)
     * }
     */
    public static MethodHandle decodeJABCodeWithObservations$handle() {
        return decodeJABCodeWithObservations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeWithObservations(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, void *observation_buffer, jab_int32 buffer_capacity, jab_int32 *observation_count)
     * }
     */
    public static MemorySegment decodeJABCodeWithObservations$address() {
        return decodeJABCodeWithObservations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_data *decodeJABCodeWithObservations(jab_bitmap *bitmap, jab_int32 mode, jab_int32 *status, void *observation_buffer, jab_int32 buffer_capacity, jab_int32 *observation_count)
     * }
     */
    public static MemorySegment decodeJABCodeWithObservations(MemorySegment bitmap, int mode, MemorySegment status, MemorySegment observation_buffer, int buffer_capacity, MemorySegment observation_count) {
        var mh$ = decodeJABCodeWithObservations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("decodeJABCodeWithObservations", bitmap, mode, status, observation_buffer, buffer_capacity, observation_count);
            }
            return (MemorySegment)mh$.invokeExact(bitmap, mode, status, observation_buffer, buffer_capacity, observation_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class resetDecoderState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("resetDecoderState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void resetDecoderState()
     * }
     */
    public static FunctionDescriptor resetDecoderState$descriptor() {
        return resetDecoderState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void resetDecoderState()
     * }
     */
    public static MethodHandle resetDecoderState$handle() {
        return resetDecoderState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void resetDecoderState()
     * }
     */
    public static MemorySegment resetDecoderState$address() {
        return resetDecoderState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void resetDecoderState()
     * }
     */
    public static void resetDecoderState() {
        var mh$ = resetDecoderState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("resetDecoderState");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class saveImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_CHAR,
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("saveImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_boolean saveImage(jab_bitmap *bitmap, jab_char *filename)
     * }
     */
    public static FunctionDescriptor saveImage$descriptor() {
        return saveImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_boolean saveImage(jab_bitmap *bitmap, jab_char *filename)
     * }
     */
    public static MethodHandle saveImage$handle() {
        return saveImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_boolean saveImage(jab_bitmap *bitmap, jab_char *filename)
     * }
     */
    public static MemorySegment saveImage$address() {
        return saveImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_boolean saveImage(jab_bitmap *bitmap, jab_char *filename)
     * }
     */
    public static byte saveImage(MemorySegment bitmap, MemorySegment filename) {
        var mh$ = saveImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("saveImage", bitmap, filename);
            }
            return (byte)mh$.invokeExact(bitmap, filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class saveImageCMYK {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_CHAR,
            jabcode_h.C_POINTER,
            jabcode_h.C_CHAR,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("saveImageCMYK");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_boolean saveImageCMYK(jab_bitmap *bitmap, jab_boolean isCMYK, jab_char *filename)
     * }
     */
    public static FunctionDescriptor saveImageCMYK$descriptor() {
        return saveImageCMYK.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_boolean saveImageCMYK(jab_bitmap *bitmap, jab_boolean isCMYK, jab_char *filename)
     * }
     */
    public static MethodHandle saveImageCMYK$handle() {
        return saveImageCMYK.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_boolean saveImageCMYK(jab_bitmap *bitmap, jab_boolean isCMYK, jab_char *filename)
     * }
     */
    public static MemorySegment saveImageCMYK$address() {
        return saveImageCMYK.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_boolean saveImageCMYK(jab_bitmap *bitmap, jab_boolean isCMYK, jab_char *filename)
     * }
     */
    public static byte saveImageCMYK(MemorySegment bitmap, byte isCMYK, MemorySegment filename) {
        var mh$ = saveImageCMYK.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("saveImageCMYK", bitmap, isCMYK, filename);
            }
            return (byte)mh$.invokeExact(bitmap, isCMYK, filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jabcode_h.C_POINTER,
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern jab_bitmap *readImage(jab_char *filename)
     * }
     */
    public static FunctionDescriptor readImage$descriptor() {
        return readImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern jab_bitmap *readImage(jab_char *filename)
     * }
     */
    public static MethodHandle readImage$handle() {
        return readImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern jab_bitmap *readImage(jab_char *filename)
     * }
     */
    public static MemorySegment readImage$address() {
        return readImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern jab_bitmap *readImage(jab_char *filename)
     * }
     */
    public static MemorySegment readImage(MemorySegment filename) {
        var mh$ = readImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readImage", filename);
            }
            return (MemorySegment)mh$.invokeExact(filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reportError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jabcode_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("reportError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void reportError(jab_char *message)
     * }
     */
    public static FunctionDescriptor reportError$descriptor() {
        return reportError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void reportError(jab_char *message)
     * }
     */
    public static MethodHandle reportError$handle() {
        return reportError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void reportError(jab_char *message)
     * }
     */
    public static MemorySegment reportError$address() {
        return reportError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void reportError(jab_char *message)
     * }
     */
    public static void reportError(MemorySegment message) {
        var mh$ = reportError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reportError", message);
            }
            mh$.invokeExact(message);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

