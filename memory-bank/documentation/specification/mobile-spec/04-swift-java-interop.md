# Swift-Java Interop Architecture

**Bridge Technology:** Swift-Java bidirectional FFI  
**Purpose:** Unified codebase for Android and iOS mobile platforms  
**Alternative to:** Separate JNI + Swift C interop implementations

---

## Why Swift-Java?

### Traditional Approach Problems

**Separate JNI and Swift C Interop:**
```
Android Path:
Java/Kotlin → JNI wrapper → C native → JABCode

iOS Path:
Swift → C interop → C native → JABCode

Result: 2 separate wrapper implementations to maintain
```

**Issues:**
- ❌ Duplicate code for wrapper logic
- ❌ Platform-specific bugs difficult to reproduce
- ❌ API drift between Android and iOS
- ❌ Double maintenance burden

### Swift-Java Unified Approach

```
Unified Path:
Kotlin/Java ←→ Swift-Java Bridge ←→ Swift ←→ C interop ←→ JABCode

Result: Single Swift wrapper, shared by both platforms
```

**Benefits:**
- ✅ Write wrapper logic once in Swift
- ✅ Automatic Java/Kotlin bindings via swift-java
- ✅ Guaranteed API parity (same source = same behavior)
- ✅ Single codebase for testing and debugging

---

## Swift-Java Technology Overview

### What is Swift-Java?

**Official:** https://github.com/swiftlang/swift-java

Swift-Java enables **bidirectional interop** between Swift and JVM languages:
- **Swift → Java:** Call Java/Kotlin code from Swift
- **Java → Swift:** Call Swift code from Java/Kotlin (our use case)

**Mechanism:**
1. Swift code annotated with `@JavaClass`, `@JavaMethod`
2. Swift compiler generates JNI bindings automatically
3. Java/Kotlin sees Swift classes as native Java classes

**No manual JNI code required.**

---

## Architecture Layers

### Layer 1: JABCode Native C

```c
// @/src/jabcode/encoder.c, decoder.c, etc.
// Pure C implementation, platform-agnostic
// NO changes required for mobile
```

**Responsibilities:**
- Core encoding/decoding algorithms
- LDPC error correction
- Finder pattern detection
- All ISO-compliant logic

### Layer 2: Mobile Bridge (C)

```c
// @/swift-java-wrapper/src/mobile_bridge.c
// Platform-agnostic C API, no image I/O

jab_encode* jabMobileEncodeCreate(...);
jab_data* jabMobileDecode(...);
void jabMobileEncodeFree(...);
```

**Responsibilities:**
- Expose JABCode functions via simple C API
- Handle RGBA buffer I/O (no PNG/TIFF)
- Error handling and validation
- Thread safety if needed

### Layer 3: Swift Wrapper

```swift
// @/swift-java-wrapper/src/swift/JABCode.swift
// Swift abstraction over C bridge

@JavaClass("com.jabcode.mobile.JABCodeEncoder")
public class JABCodeEncoder {
    @JavaMethod
    public func encode(_ data: String, colorMode: Int32) throws -> Data
}

@JavaClass("com.jabcode.mobile.JABCodeDecoder")
public class JABCodeDecoder {
    @JavaMethod
    public func decode(imageData: Data, width: Int32, height: Int32) throws -> String
}
```

**Responsibilities:**
- Swift-friendly API (throws, optionals, Data types)
- Memory management (ARC, automatic cleanup)
- C interop via Swift C bridge
- Error translation (C errors → Swift exceptions)

### Layer 4: Java/Kotlin API (Auto-Generated)

```kotlin
// Auto-generated by swift-java compiler
package com.jabcode.mobile

class JABCodeEncoder {
    fun encode(data: String, colorMode: Int): ByteArray
}

class JABCodeDecoder {
    fun decode(imageData: ByteArray, width: Int, height: Int): String
}
```

**Responsibilities:**
- Java-friendly API (exceptions, byte arrays)
- Automatic JNI marshalling
- Type safety (Int, String, ByteArray)

### Layer 5: Platform Integration

**Android:**
```kotlin
// @/swift-java-wrapper/android/src/main/kotlin/CameraScanner.kt
class JABCodeScanner(context: Context) {
    fun startScanning(onResult: (String) -> Unit) {
        // CameraX integration
        // Bitmap → ByteArray → JABCodeDecoder
    }
}
```

**iOS:**
```swift
// @/swift-java-wrapper/ios/Sources/CameraScanner.swift
class JABCodeScanner {
    func startScanning(onResult: @escaping (String) -> Void) {
        // AVFoundation integration
        // CVPixelBuffer → Data → JABCodeDecoder
    }
}
```

---

## Swift Wrapper Implementation

### Project Structure

```
@/swift-java-wrapper/
├── Sources/
│   ├── JABCode/
│   │   ├── JABCodeEncoder.swift
│   │   ├── JABCodeDecoder.swift
│   │   ├── JABCodeError.swift
│   │   └── JABCodeTypes.swift
│   └── JABCodeNative/
│       ├── include/
│       │   ├── mobile_bridge.h
│       │   └── jabcode.h
│       └── mobile_bridge.c
├── Tests/
│   └── JABCodeTests/
│       ├── EncoderTests.swift
│       └── DecoderTests.swift
└── Package.swift
```

### Package.swift

```swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "JABCode",
    platforms: [
        .iOS(.v13),
        .macOS(.v10_15)
    ],
    products: [
        .library(
            name: "JABCode",
            targets: ["JABCode"]
        ),
    ],
    dependencies: [
        .package(url: "https://github.com/swiftlang/swift-java", branch: "main")
    ],
    targets: [
        // Native C layer
        .target(
            name: "JABCodeNative",
            path: "../../src/jabcode",
            exclude: ["image.c", "Makefile"],
            sources: [
                "encoder.c", "decoder.c", "ldpc.c", "detector.c",
                "binarizer.c", "mask.c", "sample.c", "transform.c",
                "interleave.c", "pseudo_random.c"
            ],
            publicHeadersPath: "include",
            cSettings: [
                .define("MOBILE_BUILD"),
                .unsafeFlags(["-O3", "-ffast-math"])
            ]
        ),
        
        // Swift wrapper
        .target(
            name: "JABCode",
            dependencies: [
                "JABCodeNative",
                .product(name: "JavaRuntime", package: "swift-java")
            ]
        ),
        
        // Tests
        .testTarget(
            name: "JABCodeTests",
            dependencies: ["JABCode"]
        ),
    ]
)
```

### JABCodeEncoder.swift

```swift
import Foundation
import JavaRuntime
import JABCodeNative

@JavaClass("com.jabcode.mobile.JABCodeEncoder")
public class JABCodeEncoder {
    
    // Java-visible color mode constants
    @JavaStaticField
    public static let COLOR_MODE_4: Int32 = 4
    
    @JavaStaticField
    public static let COLOR_MODE_8: Int32 = 8
    
    @JavaStaticField
    public static let COLOR_MODE_16: Int32 = 16
    
    private let colorMode: Int32
    private let eccLevel: Int32
    
    @JavaConstructor
    public init(colorMode: Int32 = 8, eccLevel: Int32 = 3) {
        self.colorMode = colorMode
        self.eccLevel = eccLevel
    }
    
    @JavaMethod
    public func encode(_ data: String) throws -> EncodedResult {
        guard colorMode != 256 else {
            throw JABCodeError.unsupportedColorMode(256)
        }
        
        let dataBytes = [UInt8](data.utf8)
        
        // Create encoding parameters
        var params = jab_mobile_encode_params(
            color_number: colorMode,
            symbol_number: 1,
            ecc_level: eccLevel,
            module_size: 12
        )
        
        // Call native encoder
        guard let encoder = dataBytes.withUnsafeBytes({ dataPtr in
            jabMobileEncodeCreate(
                nil,  // No input buffer for encoding
                0, 0,
                dataPtr.baseAddress?.assumingMemoryBound(to: jab_char.self),
                Int32(dataBytes.count),
                &params
            )
        }) else {
            throw JABCodeError.encodingFailed(
                String(cString: jabMobileGetLastError() ?? "Unknown error")
            )
        }
        defer { jabMobileEncodeFree(encoder) }
        
        // Extract bitmap
        guard let bitmap = encoder.pointee.bitmap else {
            throw JABCodeError.encodingFailed("No bitmap generated")
        }
        
        let width = bitmap.pointee.width
        let height = bitmap.pointee.height
        let pixelCount = Int(width * height * 4)
        
        let imageData = Data(bytes: bitmap.pointee.pixel, count: pixelCount)
        
        return EncodedResult(
            imageData: imageData,
            width: Int(width),
            height: Int(height)
        )
    }
}

@JavaClass("com.jabcode.mobile.EncodedResult")
public struct EncodedResult {
    @JavaField
    public let imageData: Data
    
    @JavaField
    public let width: Int
    
    @JavaField
    public let height: Int
}
```

### JABCodeDecoder.swift

```swift
import Foundation
import JavaRuntime
import JABCodeNative

@JavaClass("com.jabcode.mobile.JABCodeDecoder")
public class JABCodeDecoder {
    
    @JavaConstructor
    public init() {}
    
    @JavaMethod
    public func decode(imageData: Data, width: Int32, height: Int32) throws -> String {
        let expectedSize = Int(width * height * 4)
        guard imageData.count == expectedSize else {
            throw JABCodeError.invalidImageSize(
                expected: expectedSize, 
                actual: imageData.count
            )
        }
        
        // Call native decoder
        let result = imageData.withUnsafeBytes { bufferPtr in
            jabMobileDecode(
                bufferPtr.baseAddress?.assumingMemoryBound(to: jab_byte.self),
                width,
                height
            )
        }
        
        guard let decoded = result else {
            throw JABCodeError.decodingFailed(
                String(cString: jabMobileGetLastError() ?? "Unknown error")
            )
        }
        defer { jabMobileDataFree(decoded) }
        
        // Extract string from jab_data
        let length = Int(decoded.pointee.length)
        let dataPtr = decoded.pointee.data
        
        guard let string = String(
            bytesNoCopy: UnsafeMutableRawPointer(mutating: dataPtr),
            length: length,
            encoding: .utf8,
            freeWhenDone: false
        ) else {
            throw JABCodeError.decodingFailed("Invalid UTF-8 data")
        }
        
        return string
    }
    
    @JavaMethod
    public func decodeFromFile(imagePath: String) throws -> String {
        // Load image file, convert to RGBA, call decode()
        // Implementation depends on platform (UIImage on iOS, Bitmap on Android)
        fatalError("Platform-specific implementation required")
    }
}
```

### JABCodeError.swift

```swift
import Foundation
import JavaRuntime

@JavaClass("com.jabcode.mobile.JABCodeError")
public enum JABCodeError: Error {
    case encodingFailed(String)
    case decodingFailed(String)
    case unsupportedColorMode(Int32)
    case invalidImageSize(expected: Int, actual: Int)
    case nativeLibraryNotLoaded
    
    @JavaMethod
    public var localizedDescription: String {
        switch self {
        case .encodingFailed(let msg):
            return "Encoding failed: \(msg)"
        case .decodingFailed(let msg):
            return "Decoding failed: \(msg)"
        case .unsupportedColorMode(let mode):
            return "Unsupported color mode: \(mode) (use 4, 8, 16, 32, 64, or 128)"
        case .invalidImageSize(let expected, let actual):
            return "Invalid image size: expected \(expected) bytes, got \(actual)"
        case .nativeLibraryNotLoaded:
            return "Native JABCode library not loaded"
        }
    }
}
```

---

## Java/Kotlin Usage (Auto-Generated API)

### Android Application

```kotlin
// app/src/main/kotlin/MainActivity.kt
import com.jabcode.mobile.JABCodeEncoder
import com.jabcode.mobile.JABCodeDecoder

class MainActivity : AppCompatActivity() {
    
    private val encoder = JABCodeEncoder(
        colorMode = JABCodeEncoder.COLOR_MODE_8,
        eccLevel = 3
    )
    
    private val decoder = JABCodeDecoder()
    
    fun encodeData(input: String) {
        try {
            val result = encoder.encode(input)
            
            // Convert to Android Bitmap
            val bitmap = Bitmap.createBitmap(
                result.width,
                result.height,
                Bitmap.Config.ARGB_8888
            )
            
            val buffer = ByteBuffer.wrap(result.imageData)
            bitmap.copyPixelsFromBuffer(buffer)
            
            imageView.setImageBitmap(bitmap)
            
        } catch (e: JABCodeError) {
            Log.e("JABCode", "Encoding failed: ${e.localizedDescription}")
        }
    }
    
    fun decodeFromBitmap(bitmap: Bitmap) {
        try {
            // Convert Bitmap to byte array
            val buffer = ByteBuffer.allocate(bitmap.byteCount)
            bitmap.copyPixelsToBuffer(buffer)
            
            val result = decoder.decode(
                imageData = buffer.array(),
                width = bitmap.width,
                height = bitmap.height
            )
            
            textView.text = result
            
        } catch (e: JABCodeError) {
            Log.e("JABCode", "Decoding failed: ${e.localizedDescription}")
        }
    }
}
```

### Camera Integration (Android)

```kotlin
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy

class JABCodeCameraScanner(
    private val context: Context,
    private val onResult: (String) -> Unit
) {
    private val decoder = JABCodeDecoder()
    
    fun createAnalyzer(): ImageAnalysis.Analyzer {
        return ImageAnalysis.Analyzer { image ->
            try {
                val result = decodeFromImageProxy(image)
                if (result != null) {
                    onResult(result)
                }
            } finally {
                image.close()
            }
        }
    }
    
    private fun decodeFromImageProxy(image: ImageProxy): String? {
        val buffer = image.planes[0].buffer
        val bytes = ByteArray(buffer.remaining())
        buffer.get(bytes)
        
        return try {
            decoder.decode(
                imageData = bytes,
                width = image.width,
                height = image.height
            )
        } catch (e: JABCodeError) {
            null  // Decoding failed, try next frame
        }
    }
}
```

---

## Memory Management

### Swift Side (ARC)

```swift
class JABCodeEncoder {
    private var nativeEncoder: UnsafeMutablePointer<jab_encode>?
    
    deinit {
        // Automatic cleanup via ARC
        if let encoder = nativeEncoder {
            jabMobileEncodeFree(encoder)
        }
    }
}
```

**Benefit:** Swift's Automatic Reference Counting handles cleanup.

### Java/Kotlin Side (Manual)

```kotlin
class JABCodeEncoder : Closeable {
    
    override fun close() {
        // Release Swift object
        // Swift-Java bridge handles this automatically
    }
    
    companion object {
        // Use-with pattern for automatic cleanup
        inline fun <T> use(block: (JABCodeEncoder) -> T): T {
            return JABCodeEncoder().use(block)
        }
    }
}

// Usage:
JABCodeEncoder.use { encoder ->
    val result = encoder.encode("data")
    // Automatic cleanup when block exits
}
```

### Buffer Ownership

**Rule:** Caller owns input buffers, callee owns output buffers.

```swift
func decode(imageData: Data, ...) throws -> String {
    // imageData: Owned by caller (Java/Kotlin)
    //            Swift borrows via withUnsafeBytes
    //            No copy needed
    
    let result = imageData.withUnsafeBytes { ptr in
        jabMobileDecode(ptr.baseAddress, width, height)
    }
    
    // result: Owned by native C (must free)
    defer { jabMobileDataFree(result) }
    
    // Return value: New Swift String (copied from C)
    //               Java gets new String (another copy)
    //               Original C buffer freed by defer
    return String(cString: result.pointee.data)
}
```

**Zero-Copy Optimization (Advanced):**
```swift
// For large buffers, use direct ByteBuffer sharing
@JavaMethod
func decodeZeroCopy(imageBuffer: JavaByteBuffer, ...) throws -> String {
    imageBuffer.withUnsafeMutableBytes { ptr in
        // Direct access to Java's ByteBuffer memory
        // No copy needed
        jabMobileDecode(ptr.baseAddress, width, height)
    }
}
```

---

## Threading Model

### Swift Thread Safety

```swift
@JavaClass("com.jabcode.mobile.JABCodeEncoder")
public class JABCodeEncoder {
    
    private let queue = DispatchQueue(label: "com.jabcode.encoder")
    
    @JavaMethod
    public func encode(_ data: String) throws -> EncodedResult {
        // Ensure thread safety by serializing access
        return try queue.sync {
            // Native C calls here
            ...
        }
    }
}
```

### Java Thread Safety

```kotlin
class JABCodeEncoder {
    private val lock = ReentrantLock()
    
    fun encode(data: String): EncodedResult {
        lock.withLock {
            // Swift-Java bridge is thread-safe
            // But native C may not be
            return encodeInternal(data)
        }
    }
}
```

**Recommendation:** For mobile, single-threaded encoding/decoding is sufficient. Avoid complexity unless needed.

---

## Build Integration

### Android Gradle

```gradle
// app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'swift-java-plugin'  // Swift-Java integration
}

android {
    // ... standard config
    
    externalNativeBuild {
        cmake {
            path file('src/main/cpp/CMakeLists.txt')
        }
    }
}

dependencies {
    implementation 'org.swift.java:runtime:0.1.0'  // Swift-Java runtime
    implementation files('libs/JABCode.jar')       // Generated from Swift
}

tasks.register('buildSwiftModule', Exec) {
    workingDir '../../swift-java-wrapper'
    commandLine 'swift', 'build', '-c', 'release', '--triple', 'aarch64-unknown-linux-android'
}

tasks.named('preBuild').configure {
    dependsOn 'buildSwiftModule'
}
```

### iOS Xcode

**Framework Integration:**
```ruby
# Podfile
platform :ios, '13.0'

target 'YourApp' do
  use_frameworks!
  
  # Local Swift package
  pod 'JABCode', :path => '../swift-java-wrapper'
end
```

**Swift Package Manager:**
```swift
// Package.swift (app level)
dependencies: [
    .package(path: "../swift-java-wrapper")
],
targets: [
    .target(
        name: "YourApp",
        dependencies: ["JABCode"]
    )
]
```

---

## Debugging

### Swift Side

```swift
// Add logging
import os.log

let logger = OSLog(subsystem: "com.jabcode.mobile", category: "encoder")

@JavaMethod
public func encode(_ data: String) throws -> EncodedResult {
    os_log("Encoding %d bytes with color mode %d", 
           log: logger, type: .info, data.count, colorMode)
    
    let result = try encodeInternal(data)
    
    os_log("Encoding succeeded: %dx%d image", 
           log: logger, type: .info, result.width, result.height)
    
    return result
}
```

### Java Side

```kotlin
class JABCodeEncoder {
    companion object {
        private const val TAG = "JABCodeEncoder"
        
        init {
            System.loadLibrary("swift-java-runtime")
            System.loadLibrary("jabcode-swift")
            Log.d(TAG, "Native libraries loaded")
        }
    }
    
    fun encode(data: String): EncodedResult {
        Log.d(TAG, "Encoding: $data")
        val result = encodeNative(data)
        Log.d(TAG, "Result: ${result.width}x${result.height}")
        return result
    }
}
```

### Cross-Language Debugging

**Xcode + Android Studio:**
1. Set breakpoint in Swift code
2. Attach Xcode debugger to Android app process
3. Step through Swift → C → Java stack

**LLDB Commands:**
```bash
# Attach to Android app
lldb --attach-pid <pid>

# Set Swift breakpoint
br set -n JABCodeEncoder.encode

# View Swift variables
fr v self
po imageData
```

---

## Limitations & Workarounds

### Swift-Java Maturity

**Status:** Swift-Java is experimental (as of 2026).

**Known Issues:**
- Complex generics not fully supported
- Some Swift features (protocol extensions, property wrappers) may not bridge
- Performance overhead compared to direct JNI (acceptable for mobile use case)

**Workarounds:**
- Keep Swift API simple (no complex generics)
- Use basic types: Int32, String, Data, ByteArray
- Profile performance early, optimize if needed

### Platform-Specific Code

**Problem:** Some features require platform APIs (camera, file I/O).

**Solution: Conditional Compilation**
```swift
#if os(iOS)
import UIKit

public func decodeFromImage(_ image: UIImage) throws -> String {
    guard let cgImage = image.cgImage else {
        throw JABCodeError.decodingFailed("Invalid image")
    }
    // Convert CGImage → RGBA → decode
}

#elseif os(Android)
// Android-specific implementation via Java
// This code doesn't compile on Swift, so delegate to Java

@JavaMethod
public func decodeFromBitmap(bitmap: JavaObject) throws -> String {
    // Java side handles Bitmap → ByteArray conversion
    fatalError("Call from Java side only")
}
#endif
```

**Better Approach:** Keep platform-specific code in platform layer (Layer 5), not Swift wrapper (Layer 3).

---

## Performance Considerations

### Swift-Java Overhead

**Typical overhead:** 5-10 microseconds per JNI call (Swift → Java boundary).

**Impact on JABCode:**
- Encoding: 1-2 calls per operation → <20μs overhead (negligible)
- Decoding: 1-2 calls per operation → <20μs overhead (negligible)
- Total operation time: 50-150ms → Overhead <0.02%

**Conclusion:** Swift-Java overhead is **not** a bottleneck for JABCode.

### Memory Copies

**Worst case:** 3 copies for image data
1. Java ByteArray → Swift Data (JNI copy)
2. Swift Data → C buffer (Swift bridge copy)
3. C buffer → Native processing (internal copy)

**Optimization: Direct ByteBuffer**
```swift
@JavaMethod
func decodeNoCopy(buffer: JavaDirectByteBuffer, width: Int32, height: Int32) throws -> String {
    // Access Java's direct ByteBuffer memory without copy
    let ptr = buffer.baseAddress
    return try decodeFromPointer(ptr, width, height)
}
```

**Savings:** Eliminates copy #1, total overhead reduced to ~1 copy.

---

## Comparison: Swift-Java vs Traditional JNI

| Aspect | Swift-Java | Traditional JNI |
|--------|-----------|-----------------|
| **Code duplication** | ✅ Single Swift wrapper | ❌ Separate JNI + Swift C |
| **Maintenance** | ✅ One codebase | ❌ Two codebases |
| **API parity** | ✅ Guaranteed (same source) | ⚠️ Manual synchronization |
| **Type safety** | ✅ Compile-time checked | ⚠️ Runtime JNI errors |
| **Development speed** | ✅ Faster (auto-generated bindings) | ❌ Slower (manual JNI) |
| **Performance** | ⚠️ ~10μs overhead per call | ✅ Direct JNI (~5μs) |
| **Maturity** | ⚠️ Experimental | ✅ Stable (20+ years) |
| **Community support** | ⚠️ Limited | ✅ Extensive |

**Recommendation for JABCode:** Swift-Java is **acceptable** given minimal performance impact and significant maintenance benefits.

---

## Migration Path (If Swift-Java Unavailable)

### Fallback: Separate Implementations

**Android (JNI):**
```java
// JNI wrapper (manual)
public class JABCodeEncoder {
    static {
        System.loadLibrary("jabcode-jni");
    }
    
    public native byte[] encode(String data, int colorMode);
}
```

```c
// jabcode_jni.c
JNIEXPORT jbyteArray JNICALL
Java_com_jabcode_JABCodeEncoder_encode(JNIEnv* env, jobject obj, jstring data, jint colorMode) {
    // Manual JNI marshalling
    const char* str = (*env)->GetStringUTFChars(env, data, NULL);
    // ... call jabMobileEncodeCreate ...
    (*env)->ReleaseStringUTFChars(env, data, str);
    return resultArray;
}
```

**iOS (Swift C Interop):**
```swift
// Direct C interop (no Swift-Java)
public class JABCodeEncoder {
    public func encode(_ data: String) throws -> Data {
        let cString = (data as NSString).utf8String
        // ... call jabMobileEncodeCreate ...
    }
}
```

**Result:** 2× development effort, but proven technology.

---

## Summary

**Swift-Java Advantages:**
- ✅ Single codebase for mobile wrapper
- ✅ Guaranteed Android/iOS parity
- ✅ Reduced maintenance burden
- ✅ Modern, type-safe API

**Swift-Java Challenges:**
- ⚠️ Experimental technology (maturity risk)
- ⚠️ Minimal overhead (acceptable for JABCode)
- ⚠️ Platform-specific features need delegation

**Recommendation:** Use Swift-Java for JABCode mobile implementation. The maintenance benefits outweigh the experimental risk for this use case.

**Next:** See `05-implementation-roadmap.md` for phased delivery plan.
