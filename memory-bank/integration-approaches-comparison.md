# JABCode Java Integration: Three Approaches Compared

## Overview

Three viable approaches for integrating the JABCode C library with Java/Android applications.

## Architecture Comparison

### 1. Current Approach: Direct JNI (What You Have)
```
Java ←[Manual JNI Wrapper]→ C/C++ (JABCode)
```

### 2. Project Panama (FFM API)
```
Java ←[Foreign Function & Memory API]→ C (JABCode)
```

### 3. Swift-Java Interop
```
Java ←[swift-java JNI]→ Swift ←[Swift C interop]→ C (JABCode)
```

---

## Detailed Comparison

### 1. Direct JNI (Current Implementation)

**Location:** `/javacpp-wrapper/src/main/c/`

**How it works:**
- Manual C/C++ JNI wrapper code
- `javah` or manual header generation
- Explicit memory management with `GetStringUTFChars`, `NewByteArray`, etc.
- Native methods declared in Java, implemented in C++

**Example:**
```cpp
// JABCodeNative_jni.cpp
JNIEXPORT jbyteArray JNICALL 
Java_com_jabcode_JABCodeNative_encode(JNIEnv *env, jobject obj, jstring data) {
    const char *nativeData = (*env)->GetStringUTFChars(env, data, 0);
    
    // Call JABCode C library
    jab_data* encoded = generateJABCode(params, (jab_byte*)nativeData);
    
    // Convert to Java byte array
    jbyteArray result = (*env)->NewByteArray(env, encoded->length);
    (*env)->SetByteArrayRegion(env, result, 0, encoded->length, encoded->data);
    
    (*env)->ReleaseStringUTFChars(env, data, nativeData);
    free(encoded);
    return result;
}
```

**Pros:**
- ✅ Direct, no intermediate layers (best performance)
- ✅ Mature, battle-tested since Java 1.1
- ✅ Works everywhere (Java 7+, Android)
- ✅ Full control over memory management
- ✅ No additional toolchain dependencies
- ✅ Already implemented and working

**Cons:**
- ❌ Verbose, error-prone boilerplate
- ❌ Manual memory management (potential leaks)
- ❌ Platform-specific compilation
- ❌ Poor type safety at boundaries
- ❌ Tedious to maintain and extend

**Requirements:**
- JDK 7+ with JNI headers
- C/C++ compiler
- Native library per platform

**Best for:**
- Maximum compatibility (Android)
- Projects already using JNI
- Performance-critical applications

---

### 2. Project Panama (Foreign Function & Memory API)

**How it works:**
- Pure Java solution using FFM API (JEP 454)
- `jextract` tool generates Java bindings from C headers
- No C/C++ wrapper code needed
- Type-safe method handles and memory segments
- Automatic memory management with arenas

**Example:**
```bash
# Generate Java bindings from C headers
jextract \
  --output src/main/java \
  --target-package com.jabcode.panama \
  --library jabcode \
  --include-function generateJABCode \
  --include-struct jab_data \
  --include-struct jab_encode_params \
  src/jabcode/jabcode.h
```

```java
// Generated by jextract - use directly in Java
import com.jabcode.panama.*;
import java.lang.foreign.*;

public class JABCodePanama {
    public byte[] encode(String data, int colorMode, int eccLevel) {
        try (Arena arena = Arena.ofConfined()) {
            // Allocate C structs in managed arena
            MemorySegment params = jab_encode_params.allocate(arena);
            jab_encode_params.color_number(params, colorMode);
            jab_encode_params.ecc_level(params, eccLevel);
            
            // Convert Java String to C string
            MemorySegment cString = arena.allocateFrom(data);
            
            // Call C function directly
            MemorySegment result = generateJABCode(arena, params, cString);
            
            // Access result data
            int length = jab_data.length(result);
            MemorySegment dataPtr = jab_data.data(result);
            
            // Copy to Java byte array
            return dataPtr.reinterpret(length).toArray(ValueLayout.JAVA_BYTE);
            
            // Arena automatically frees all memory when closed
        }
    }
}
```

**Pros:**
- ✅ **Pure Java** - no C/C++ wrapper code
- ✅ Automatic binding generation via `jextract`
- ✅ Type-safe at compile time
- ✅ Automatic memory management (arenas)
- ✅ Better performance than JNI (fewer copies)
- ✅ Safer than manual JNI
- ✅ Official JDK solution (JEP 454)
- ✅ Easier to maintain and extend

**Cons:**
- ❌ **Requires JDK 22+** (LTS in JDK 25)
- ❌ **Not available on Android** (stuck on Java 8)
- ❌ Still relatively new (production since 2024)
- ❌ Need to ship native library per platform
- ❌ Less documentation than JNI

**Requirements:**
- JDK 22+ (FFM API finalized)
- `jextract` tool
- JABCode C library compiled per platform

**Best for:**
- **Desktop applications** (server, Linux, Windows, macOS)
- New Java projects on modern JDK
- Projects wanting to eliminate C wrapper code
- Teams preferring pure Java solutions

---

### 3. Swift-Java Interop

**How it works:**
- Swift package wraps C library (Swift has native C interop)
- `swift-java jextract` generates JNI bindings
- `@JavaImplementation` macro bridges Java native methods to Swift
- JNI handled automatically by macros

**Example:**
```java
// Java side
package com.jabcode;

public class JABCodeService {
    public native byte[] encode(String data, int colorMode, int eccLevel);
    
    static {
        System.loadLibrary("JABCodeSwift");
    }
}
```

```swift
// Swift side
import JavaKit

// Swift module wraps C library
import JABCodeC  // C library via module map

@JavaImplementation("com.jabcode.JABCodeService")
extension JABCodeService {
    @JavaMethod
    public func encode(data: String, colorMode: Int32, eccLevel: Int32) -> [UInt8] {
        data.withCString { cString in
            var params = jab_encode_params()
            params.color_number = colorMode
            params.ecc_level = eccLevel
            
            // Call C function
            guard let encoded = generateJABCode(cString, &params) else {
                return []
            }
            
            // Convert to Swift array (auto-converts to Java byte[])
            let result = Array(UnsafeBufferPointer(
                start: encoded.pointee.data,
                count: Int(encoded.pointee.length)
            ))
            
            free(encoded)
            return result
        }
    }
}
```

**Pros:**
- ✅ Type-safe Swift layer
- ✅ Automatic JNI boilerplate via macros
- ✅ Better error handling than C
- ✅ Cross-platform Swift reuse (iOS, Android, server)
- ✅ Works on Android (JNI mode)
- ✅ Cleaner code than manual JNI

**Cons:**
- ❌ **Requires Swift 6.2+ toolchain**
- ❌ Adds intermediate layer (Java → Swift → C)
- ❌ Build complexity (Swift + Java + C)
- ❌ Team needs Swift knowledge
- ❌ Less mature than JNI
- ❌ Debugging across three layers
- ❌ Larger binary size

**Requirements:**
- Swift 6.2+ toolchain
- JDK 17+ (or Java 7+ for JNI mode)
- swift-java library
- JABCode C library

**Best for:**
- Projects already using Swift
- Cross-platform Swift frameworks
- Teams with Swift expertise
- Android apps with Swift components

---

## Side-by-Side Comparison

| Feature | Direct JNI | Project Panama | Swift-Java |
|---------|-----------|----------------|------------|
| **Java Version** | 7+ | 22+ | 17+ (JNI: 7+) |
| **Android Support** | ✅ Yes | ❌ No | ✅ Yes |
| **Native Code** | C++ wrapper | None | Swift wrapper |
| **Boilerplate** | High | Low | Low |
| **Type Safety** | Low | High | High |
| **Performance** | Excellent | Excellent | Very Good |
| **Memory Safety** | Manual | Automatic | Automatic |
| **Binding Generation** | Manual | Automatic | Automatic |
| **Maturity** | Very High | Medium | Low |
| **Learning Curve** | Medium | Low | High |
| **Maintenance** | High effort | Low effort | Medium effort |

---

## Code Size Comparison (Estimated)

### Direct JNI
- **Java:** 200 lines (native method declarations)
- **C++:** 500 lines (JNI wrapper implementation)
- **Total:** 700 lines

### Project Panama
- **Java:** 100 lines (business logic)
- **Generated:** 2000+ lines (auto-generated, don't maintain)
- **Maintained:** 100 lines

### Swift-Java
- **Java:** 100 lines (native declarations)
- **Swift:** 150 lines (implementation)
- **Total:** 250 lines maintained

---

## Performance Comparison

### Throughput (relative, higher is better)
- **Direct JNI:** 100% (baseline)
- **Project Panama:** 95-105% (comparable, sometimes faster)
- **Swift-Java:** 90-95% (extra Swift layer)

### Memory Overhead
- **Direct JNI:** Minimal (manual management)
- **Project Panama:** Low (arena allocation)
- **Swift-Java:** Medium (Swift runtime + JNI)

---

## Decision Matrix

### Choose **Direct JNI** (Current) if:
- ✅ Android support is required
- ✅ Maximum compatibility needed
- ✅ Current solution works well
- ✅ No Swift infrastructure
- ✅ Team familiar with C/C++

### Choose **Project Panama** if:
- ✅ Desktop/server only (JDK 22+)
- ✅ Want to eliminate C wrapper code
- ✅ Prefer pure Java solution
- ✅ Starting new project
- ✅ Value maintainability over compatibility

### Choose **Swift-Java** if:
- ✅ Already using Swift in project
- ✅ Building cross-platform Swift framework
- ✅ Want Swift's safety features
- ✅ Android support needed (unlike Panama)
- ✅ Team has Swift expertise

---

## Migration Paths

### Current JNI → Project Panama
**Effort:** Medium
**Timeline:** 1-2 weeks

Steps:
1. Install JDK 22+
2. Run `jextract` on JABCode headers
3. Replace JNI wrapper with Panama API calls
4. Test thoroughly
5. Update deployment (JDK 22+ required)

**Blockers:** Android support (no FFM on Android)

### Current JNI → Swift-Java
**Effort:** High
**Timeline:** 3-4 weeks

Steps:
1. Set up Swift 6.2+ toolchain
2. Create Swift package wrapping JABCode
3. Define Java native methods
4. Generate bindings with `swift-java jextract --mode=jni`
5. Implement Swift wrapper
6. Build and test
7. Update deployment

**Blockers:** Swift infrastructure, team knowledge

---

## Recommendation for JABCode

### **Keep Direct JNI** ✅

**Why:**
1. **Android support is critical** - Panama doesn't work on Android
2. **Already implemented and working** - migration cost high
3. **Team likely familiar with JNI** - no learning curve
4. **Maximum compatibility** - works everywhere

### **Consider Panama for Desktop-Only Fork**

If you want a **desktop/server** version without Android:
1. Create `jabcode-panama` module
2. Generate bindings with `jextract`
3. Maintain both (JNI for Android, Panama for desktop)

### **Skip Swift-Java Unless...**

Only adopt if:
- You're already building Swift components
- You want to unify iOS/Android native code in Swift
- You're starting fresh

---

## Proof-of-Concept Locations

- **Current JNI:** `/javacpp-wrapper/` (production)
- **Project Panama:** `/panama-poc/` (to be created)
- **Swift-Java:** `/swift-java-poc/` (experimental)

---

## References

1. **Project Panama**
   - JEP 454: https://openjdk.org/jeps/454
   - Tutorial: https://foojay.io/today/project-panama-for-newbies-part-1/

2. **Swift-Java**
   - GitHub: https://github.com/swiftlang/swift-java
   - WWDC25: https://www.youtube.com/watch?v=QSHO-GUGidA
   - GSoC 2025: https://forums.swift.org/t/gsoc-2025-new-jni-mode-added-to-swift-java-jextract-tool/81858

3. **JNI Best Practices**
   - Oracle JNI Spec: https://docs.oracle.com/javase/8/docs/technotes/guides/jni/
